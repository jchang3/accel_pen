//============================================================================
// Name        : dtw.cpp
// Author      : Group 2
// Project     : ECE492 - Group 2 accelerometer pen
// Description : DTW testing package using Sakoe-Chiba band boundaries
//============================================================================
//http://www.codeproject.com/Articles/69941/Best-Square-Root-Method-Algorithm-Function-Precisi

//#include <vector>
//#include <utility>
//#include <cmath>
#include "dtw.h"
//#include <iostream>
//#include <fstream>
#define INFIN 1000000000

int min_three(int a, int b, int c);

int min_three(int a, int b, int c){
	int min = a;
	if (min > b) min = b;
	if (min > c) min = c;
	return min;
}

/* Integer square root by Halleck's method, with Legalize's speedup */
long isqrt (x) long x;{
  long   squaredbit, remainder, root;

   if (x<1) return 0;

   /* Load the binary constant 01 00 00 ... 00, where the number
    * of zero bits to the right of the single one bit
    * is even, and the one bit is as far left as is consistant
    * with that condition.)
    */
   squaredbit  = (long) ((((unsigned long) ~0L) >> 1) &
                        ~(((unsigned long) ~0L) >> 2));
   /* This portable load replaces the loop that used to be
    * here, and was donated by  legalize@xmission.com
    */

   /* Form bits of the answer. */
   remainder = x;  root = 0;
   while (squaredbit > 0) {
     if (remainder >= (squaredbit | root)) {
         remainder -= (squaredbit | root);
         root >>= 1; root |= squaredbit;
     } else {
         root >>= 1;
     }
     squaredbit >>= 2;
   }

   return root;
}

int dtw(int * t1, int * t2, int n, int m){
//	int i;
//	for (i = 0; i < n; i++) {
//		printf("%d  %d\n", i, t1[i]);
//	}
//	printf("\n");
//	for (i = 0; i < m; i++) {
//		printf("%d  %d\n", i, t2[i]);
//	}
}
//
//#define INFIN 10000000
//
//namespace DTW {
//
//	//euclidean distance
//    int dist(int x, int y) {
//        return sqrt(pow((x - y), 2));
//    }
//
//    //returns minimum of three numbers
//    int minimum(int x, int y, int z){
//    	return x < y ? (x < z ? x : z) : (y < z ? y : z);
//    }
//
//    //matrix output for debugging
//    void print_matrix(int* cost, int m, int n){
//    	        std::ofstream myfile;
//    	        myfile.open ("example.txt");
//    	        for(int i = 0; i < m; i++){
//    	        	for(int j = 0; j < n; j++){
//    	        		myfile << *(cost+(i*n+j)) << ", ";
//    	            }
//    	            myfile << std::endl;
//    	        }
//    	        myfile.close();
//    }
//
//    //dynamic programming approach
//    int dtw(const std::vector<int>& t1, const std::vector<int>& t2) {
//
//        int m = t1.size();
//        int n = t2.size();
//        int window = static_cast<int>(0.1*(std::max(m, n))+0.5);    //band size of 10% max of m or n
//        int constraint = std::abs(n-m);
//        window = std::max(window, constraint);
//
//        // create cost matrix
//        int cost[m][n];
//
//        // setup initial state of matrix
//        for(int i = 0; i < m; i++)
//        	for(int j = 0; j < n; j++)
//        		cost[i][j] = INFIN;
//        cost[0][0] = 0;
//
//        // fill matrix
//        for(int i = 1; i < m; i++)
//            for(int j = std::max(1, i-window); j < std::min(n,i+window); j++)
//                cost[i][j] = minimum(cost[i-1][j], cost[i][j-1], cost[i-1][j-1])
//                    + dist(t1[i],t2[j]);
//
//        //print_matrix((int*)cost, m, n);
//        return cost[m-1][n-1];
//    }
//}
